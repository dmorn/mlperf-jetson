<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><!-- NVIDIA customization --><title>NVIDIA Jetson Linux Driver Package Software Features : Graphics Programming | NVIDIA Docs </title><link rel="Prev" href="graphics_comp_shader.html" title="Previous" /><link rel="Next" href="graphics_eglstream_user_guide.html" title="Next" /><link rel="StyleSheet" href="../css/font-awesome/css/font-awesome.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/graphics_egldevice.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><noscript><div id="noscript_padding"></div></noscript></head><body id="pCHmCY8rt5PtsjBFuYYoK_002bw" class="ww_skin_page_body" style="visibility: hidden;"><input type="hidden" id="page_onload_url" value="../index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html"></input><span id="dropdown_ids" style="display:none;"></span><div id="ww_content_container"><header id="wwconnect_header"><div class="ww_skin_page_toolbar"><div id="dropdown_button_container" class="dropdown_container dropdown_button_container_disabled"><a id="show_hide_all" class="ww_skin ww_behavior_dropdown_toggle ww_skin_dropdown_toggle" title="Page DropDown Toggle" href="#"><i class="fa"></i></a><span class="ww_skin_page_toolbar_divider">&nbsp;</span></div><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#"><i class="fa"></i></a></div><!-- was this helpful button --><!--                         --></header><div id="page_content_container" style="background-attachment: scroll; background-image: url(&quot;watermark.png&quot;); background-position: center center; background-repeat: no-repeat; margin-left: 0pt; margin-right: 10pt; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px"><div id="page_content"><H1 id="wwpID0E0JE0HA" class="Heading_2_Top">EGLDevice</H1><div class="WebWorks_MiniTOC"><div class="WebWorks_MiniTOC_Heading">&nbsp;</div><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0HE0HA">EGLDevice</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0FE0HA">EGLOutput</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0DE0HA">EGLStream</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E05D0HA">Extensions</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0PD0HA">Runtime Configuration</a></div></dd><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0ND0HA">Conditions Requiring a Stream Surface</a></div></dd></dl><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0KD0HA">Implementation</a></div></dd><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0ID0HA">Rendering to EGLDevice</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0BD0HA">Creating a Stream Surface</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0IB0HA">Cross-Process and Cross-Partition EGLStream Applications</a></div></dd></dl><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E3HA">Connecting a Surface to a Screen</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0EVHA">Setting Up the Display with DRM</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0ECHA">Board-to-Display Connectors</a></div></dd></dl></div><div id="wwpID0E0IE0HA" class="Body_Text">This topic describes EGL mechanisms that you can use to render 3D images on a pure EGL display. Such a display does not use a window system.</div><H3 id="wwpID0E0HE0HA" class="Heading_3">EGLDevice</H3><div id="wwpID0E0GE0HA" class="Body_Text">EGLDevice provides a mechanism to access graphics functionality in the absence of or without reference to a native window system. It is a method to initialize EGL displays and surfaces directly on top of GPUs/devices rather than native window system objects. It is a cross-platform method to discover media devices like displays, GPUs, etc. The set of EGLDevice extensions boot strap EGL, without the use of any native APIs.</div><H3 id="wwpID0E0FE0HA" class="Heading_3">EGLOutput</H3><div id="wwpID0E0EE0HA" class="Body_Text">EGLOutput is to graphical outputs what EGLDevice is to devices. It allows enumeration of outputs on a device. EGLOutput allows rendering directly to a screen in the absence of a window system. Additionally, it allows applications to bypass native window systems for direct rendering. It defines certain EGL resources for referencing display control hardware associated with an EGL device. EGLOutput provides a binding between GL, NVIDIA<span style="vertical-align: super">®</span>&nbsp;CUDA<span style="vertical-align: super">®</span>, and multimedia rendering and the display output. In a typical Embedded setting, the outputs are often initialized to a fixed state at system startup. But in cases where they are configurable, other interfaces such as DRM must be used.</div><H3 id="wwpID0E0DE0HA" class="Heading_3">EGLStream</H3><div id="wwpID0E0CE0HA" class="Body_Text">EGLStream is a mechanism to share data efficiently between different APIs without copying data. APIs could be OpenGL, CUDA, Multimedia, etc. A producer and a consumer are attached to two ends of a stream object:</div><div id="wwpID0E0BE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Producer adds content into the stream.</div><div id="wwpID0E0AE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Consumer retrieves this content.</div><div id="wwpID0E06D0HA" class="Body_Text">EGLOutput instances can also be specified as consumers, allowing APIs to direct their output to the screen.</div><H3 id="wwpID0E05D0HA" class="Heading_3">Extensions</H3><div id="wwpID0E04D0HA" class="Body_Text">EGL extensions specify the behavior, procedures, and functions for these EGL mechanisms.</div><div id="wwpID0E03D0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGLDevice</span></div><div id="wwpID0E02D0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_EXT_device_base</span></div><div id="wwpID0E01D0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_EXT_platform_base</span></div><div id="wwpID0E0ZD0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_EXT_platform_device</span></div><div id="wwpID0E0YD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGLOutput</span></div><div id="wwpID0E0XD0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_EXT_output_base</span></div><div id="wwpID0E0WD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGLStream</span></div><div id="wwpID0E0VD0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_KHR_stream</span></div><div id="wwpID0E0UD0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_KHR_stream_producer_eglsurface</span></div><div id="wwpID0E0TD0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_EXT_stream_consumer_egloutput</span></div><div id="wwpID0E0SD0HA" class="Body_Text">For a description of these EGL extensions, see:</div><div id="wwpID0E0RD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>“EGL and EGL Extensions” in <span class="Emphasis">NVIDIA Jetson Linux Graphics API Reference</span></div><div id="wwpID0E0QD0HA" class="List_Bullet" style="text-align: justify"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Hyperlink"><a href="https://www.khronos.org/registry/egl" target="external_window">Khronos EGL extension specifications</a></span> on the <span class="Hyperlink"><a href="https://www.khronos.org/" target="external_window">khronos.org</a></span> web site</div><H3 id="wwpID0E0PD0HA" class="Heading_3">Runtime Configuration</H3><div id="wwpID0E0OD0HA" class="Body_Text">The sections below describe runtime configurations.</div><H4 id="wwpID0E0ND0HA" class="Heading_4">Conditions Requiring a Stream Surface</H4><div id="wwpID0E0MD0HA" class="Body_Text">In the absence of an underlying window system, the stream surface is necessary for on screen rendering. Stream surfaces behave like any other EGLSurface. For example, <span class="Code_Char">eglSwapBuffers()</span>must still be called to indicate the end of a frame. However, stream surfaces are stream producers, so <span class="Code_Char">eglSwapBuffers()</span> submits rendering to the stream rather than presenting it to a native window directly. Typically, an EGLOutput consumer can use any producer attached to the stream but needs a surface producer when rendering API is OpenGL. For more information, see <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0BD0HA" title="EGLDevice">Creating a Stream Surface</a></span>.</div><div id="wwpID0E0LD0HA" class="Body_Text">A common use case for stream producer surfaces is an application producing display frames using OpenGL, attached as a producer to one end of an EGL stream. The stream consumer on the other end is an EGLOutput layer sending frames directly to a display device.</div><H3 id="wwpID0E0KD0HA" class="Heading_3">Implementation</H3><div id="wwpID0E0JD0HA" class="Body_Text">The following two sub-sections describe the steps to render to an EGL device using a stream surface.</div><H4 id="wwpID0E0ID0HA" class="Heading_4">Rendering to EGLDevice</H4><div id="wwpID0E0HD0HA" class="Body_Text">These are the steps to render to an EGL device (more detailed steps follow):</div><div id="wwpID0E0GD0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Create an EGL display from an EGL device.</div><div id="wwpID0E0FD0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Create an EGL context from the EGL display.</div><div id="wwpID0E0ED0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Create an EGL stream producer surface.</div><div id="wwpID0E0DD0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Bind a GL context to the stream surface, i.e. make current.</div><div id="wwpID0E0CD0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Post the surface contents to the stream using swap buffers.</div><H4 id="wwpID0E0BD0HA" class="Heading_4">Creating a Stream Surface</H4><div id="wwpID0E0AD0HA" class="Body_Text">Creating a stream surface uses the following functions:</div><div class="ww_skin_page_overflow"><table class="Table_Normal" style="margin-left: 41.75pt" cellspacing="0" summary=""><tr><td style="background-color: #DDEEBF; background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top; width: 179.65pt"><div id="wwpID0EABC06C0HA" class="Cell_Heading">Function</div></td><td style="background-color: #DDEEBF; background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top; width: 222.1pt"><div id="wwpID0EAAC06C0HA" class="Cell_Heading">Extension and Function Description</div></td></tr><tr><td style="background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top"><div id="wwpID0EABB06C0HA" class="Cell_Text">eglCreateStreamProducerSurfaceKHR </div></td><td style="background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top"><div id="wwpID0EBAB06C0HA" class="Cell_Code">EGL_KHR_stream_producer_eglsurface</div><div id="wwpID0EAAB06C0HA" class="Cell_Text">Creates an EGLSurface and connects it as the producer of a stream. </div></td></tr><tr><td style="background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top"><div id="wwpID0EABA06C0HA" class="Cell_Text">eglStreamConsumerOutputEXT </div></td><td style="background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top"><div id="wwpID0EBAA06C0HA" class="Cell_Code">EGL_EXT_stream_consumer_egloutput</div><div id="wwpID0EAAA06C0HA" class="Cell_Text">Binds an EGLOutput layer as a stream consumer to send rendering directly to a display device. </div></td></tr></table></div><div id="wwpID0E05C0HA" class="Body_Text">According to the EGL_KHR_stream specification, the EGLStream cannot be used until it has been connected to a consumer and producer. The consumer must be connected before the producer is connected.</div><div id="wwpID0E04C0HA" class="Heading_5">To render to an EGLDevice through stream</div><div id="wwpID0E03C0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Query EGL extensions with <span class="Code_Char">eglGetProcAddress()</span>.</div><div id="wwpID0E02C0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Query available EGLDevices with <span class="Code_Char">eglQueryDevicesEXT()</span>.</div><div id="wwpID0E01C0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Obtain an EGL display from the EGL device with <span class="Code_Char">eglGetPlatformDisplayEXT()</span>.</div><div id="wwpID0E0ZC0HA" class="List_Continue">This step creates an EGLDisplay that does not belong to any native platform.</div><div id="wwpID0E0YC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Initialize/setup EGL with <span class="Code_Char">eglInitialize()</span>.</div><div id="wwpID0E0XC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Setup an EGLOutput. For detailed steps, see <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0EVHA" title="EGLDevice">Setting Up the Display with DRM</a></span>.</div><div id="wwpID0E0WC0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Selecting an output:</div><div id="wwpID0E0VC0HA" class="List_Bullet_3"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Can be done by enumerating all outputs and selecting a known index.</div><div id="wwpID0E0UC0HA" class="List_Bullet_3"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Can be done by looking up an output associated with a native (e.g. DRM) screen handle.</div><div id="wwpID0E0TC0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>If necessary, initialize display settings with native interfaces.</div><div id="wwpID0E0SC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>6.	</span></span>Direct rendering to an EGLOutput.</div><div id="wwpID0E0RC0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Create an EGL stream with <span class="Code_Char">eglCreateStreamKHR()</span>.</div><div id="wwpID0E0QC0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Connect the output layer to the stream. Bind consumer end of stream to EGLOutput window object with <span class="Code_Char">eglStreamConsumerOutputEXT()</span>.</div><div id="wwpID0E0PC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>7.	</span></span>Set buffer configurations by choosing an EGLConfig</div><div id="wwpID0E0OC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>8.	</span></span>Create a stream producer surface to feed the stream with <span class="Code_Char">eglCreateStreamProducerSurfaceKHR()</span>.</div><div id="wwpID0E0NC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>9.	</span></span>Create an EGL context, make it current by binding it to the stream surface with <span class="Code_Char">eglMakeCurrent</span>.</div><div id="wwpID0E0MC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>10.	</span></span>Post surface contents to the stream with <span class="Code_Char">eglSwapBuffers</span>.</div><div id="wwpID0E0LC0HA" class="Heading_5">To use an EGLStream in cross-process mode</div><div id="wwpID0E0KC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Make the following additions and changes to <span class="Code_Char">nvm_eglstream.int</span>:</div><div id="wwpID0E0JC0HA" class="Code">AddressSpace nvm_eglstream_producer</div><div id="wwpID0E0IC0HA" class="Code">  Filename      nvm_eglstream_as0</div><div id="wwpID0E0HC0HA" class="Code">  Arguments     -producer 0 -f /nfsmount/welcome_animation.264 -standalone 1</div><div id="wwpID0E0GC0HA" class="Code">  MemoryPoolSize      32M</div><div id="wwpID0E0FC0HA" class="Code">  ExtendedMemoryPoolSize    64M</div><div id="wwpID0E0EC0HA" class="Code">  HeapExtensionReservedSize 64M</div><div id="wwpID0E0DC0HA" class="Code">  Language      C</div><div id="wwpID0E0CC0HA" class="Code">  Task        Initial</div><div id="wwpID0E0BC0HA" class="Code">    StartIt     false</div><div id="wwpID0E0AC0HA" class="Code">    StackLength   2M</div><div id="wwpID0E06B0HA" class="Code">  EndTask</div><div id="wwpID0E05B0HA" class="Code">EndAddressSpace</div><div id="wwpID0E04B0HA" class="Code">&nbsp;</div><div id="wwpID0E03B0HA" class="Code">AddressSpace nvm_eglstream_consumer</div><div id="wwpID0E02B0HA" class="Code">  Filename      nvm_eglstream_as0</div><div id="wwpID0E01B0HA" class="Code">  Arguments     -consumer 0 -d 2 -standalone 2</div><div id="wwpID0E0ZB0HA" class="Code">  MemoryPoolSize      32M</div><div id="wwpID0E0YB0HA" class="Code">  ExtendedMemoryPoolSize    64M</div><div id="wwpID0E0XB0HA" class="Code">  HeapExtensionReservedSize 64M</div><div id="wwpID0E0WB0HA" class="Code">  Language      C</div><div id="wwpID0E0VB0HA" class="Code">  Task        Initial</div><div id="wwpID0E0UB0HA" class="Code">    StartIt     false</div><div id="wwpID0E0TB0HA" class="Code">    StackLength   2M</div><div id="wwpID0E0SB0HA" class="Code">  EndTask</div><div id="wwpID0E0RB0HA" class="Code">EndAddressSpace</div><div id="wwpID0E0QB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Rebuild the application.</div><div id="wwpID0E0PB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Load the application binary with the following command:</div><div id="wwpID0E0OB0HA" class="Code">Load /nfsmount/nvm_eglstream_egldevice</div><div id="wwpID0E0NB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Start the consumer with the following command:</div><div id="wwpID0E0MB0HA" class="Code">rt nvm_eglstream_consumer Initial</div><div id="wwpID0E0LB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Start the producer with the following command:</div><div id="wwpID0E0KB0HA" class="Code">rt nvm_eglstream_producer Initial</div><div id="wwpID0E0JB0HA" class="List_Continue">This procedure enables a video producer and video consumer combination. The same procedure can also be extended for other producer/consumer combinations.</div><H4 id="wwpID0E0IB0HA" class="Heading_4">Cross-Process and Cross-Partition EGLStream Applications</H4><div id="wwpID0E0HB0HA" class="Body_Text">This release includes the simple cross-process EGLDevice consumer and producer applications <span class="Code_Char">helloconsumer</span> and <span class="Code_Char">helloproducer</span>. The applications listen on 127.0.0.1, port 8888 by default. They can be used as cross-partition applications by passing <span class="Code_Char">–-crosspart</span> or <span class="Code_Char">-c</span> to the consumer and <span class="Code_Char">–-crosspart [&lt;consumer_ip&gt;]</span> or <span class="Code_Char">-c [&lt;consumer_ip&gt;]</span> to the producer.</div><div id="wwpID0E0GB0HA" class="Body_Text">The applications are built into <span class="Code_Char">demo_dd</span>.</div><div id="wwpID0E0FB0HA" class="Heading_5">To use the applications</div><div id="wwpID0E0EB0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Load <span class="Code_Char">demo_dd</span>.</div><div id="wwpID0E0DB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Start <span class="Code_Char">helloconsumer</span> on the target with the following command:</div><div id="wwpID0E0CB0HA" class="Code">rt helloconsumer Initial</div><div id="wwpID0E0BB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Start helloproducer on the target with the following command:</div><div id="wwpID0E0AB0HA" class="Code">rt helloproducer Initial</div><div id="wwpID0E6HA" class="List_Continue">If the applications run correctly, the upper-left corner of display 2 contains a flashing square.</div><div id="wwpID0E5HA" class="Body_Text">Using <span class="Code_Char">EGL_KHR_stream_consumer_gltexture</span> functionality, the EGLStream can also be bound to a gltexture consumer (requiring an EGLContext.) The consumer texture buffer can then be rendered to an EGLSurface, for example.</div><div id="wwpID0E4HA" class="Body_Text">For more information, see the documentation for <span class="Hyperlink" style="font-family: &quot;Courier New&quot;"><a href="https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_stream_consumer_gltexture.txt" target="external_window">EGL_KHR_stream_consumer_gltexture</a></span> on the <span class="Hyperlink"><a href="https://www.khronos.org/" target="external_window">khronos.org</a></span> web site.</div><H3 id="wwpID0E3HA" class="Heading_3">Connecting a Surface to a Screen</H3><div id="wwpID0E2HA" class="Body_Text">You must use an EGLStream to connect a surface (i.e., a stream surface) to a screen. The surface is the stream producer, and the screen is the stream consumer.</div><div id="wwpID0E1HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">eglGetPlatformDisplayEXT()</span> returns an EGLDisplay handle belonging to a screen as specified by platform argument in the function call.</div><div id="wwpID0EZHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">eglMakeCurrent()</span> attaches an EGL rendering context to draw and read an EGL surface. It also binds a context and a surface to the current rendering thread.</div><div id="wwpID0EYHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Steps 6 through 9 in <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0BD0HA" title="EGLDevice">Creating a Stream Surface</a></span> are required for connecting a stream surface to a screen.</div><div id="wwpID0EXHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">eglGetPlatformDisplayEXT()</span> returns a handle to screen.</div><div id="wwpID0EWHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">eglMakeCurrent()</span> binds the handle to the current context and surface.</div><H3 id="wwpID0EVHA" class="Heading_3">Setting Up the Display with DRM</H3><div id="wwpID0EUHA" class="Body_Text">The Direct Rendering Manager (DRM) is a framework to manage GPUs and displays. Managing connected monitors and displays and changing the current modes is called mode-setting and is one of the functions of DRM. As mentioned in the “If necessary, initialize display settings ...” part in Step 5 in <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_egldevice.html#wwpID0E0BD0HA" title="EGLDevice">Creating a Stream Surface</a></span>, this native interface can be used to initialize the display setting.</div><div id="wwpID0ETHA" class="Heading_5">To select an encoder, CRTC, and connector</div><div id="wwpID0ESHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Open a DRM device file with <span class="Code_Char">drmOpen()</span>.</div><div id="wwpID0ERHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Obtain DRM-KMS resources with <span class="Code_Char">drmModeGetResources()</span>.</div><div id="wwpID0EQHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>(Optional) Get plane information with <span class="Code_Char">drmModeGetPlane()</span> and <span class="Code_Char">drmModeGetPlaneResources()</span>.</div><div id="wwpID0EPHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Query the desired connector with <span class="Code_Char">drmModeGetConnector()</span>.</div><div id="wwpID0EOHA" class="List_Continue">All valid modes for a connector can be retrieved with a call to <span class="Code_Char">drmModeGetConnector()</span>. Select the mode to be used and save it. The first mode in the list is the default mode with the highest resolution possible and often a suitable choice</div><div id="wwpID0ENHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>If there is already an encoder attached to the connector, choose it with <span class="Code_Char">drmModeGetEncoder()</span>.</div><div id="wwpID0EMHA" class="List_Continue">If the attached encoder is incompatible with CRTC/plane find another one by iterating over all available encoders.</div><div id="wwpID0ELHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>6.	</span></span>Select a suitable CRTC.</div><div id="wwpID0EKHA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>For each connector, find a CRTC to drive this connector. To find a suitable CRTC, iterate over the list of encoders that are available for each connector. Each encoder contains a list of CRTCs that it can work with and select one of these CRTCs.</div><div id="wwpID0EJHA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Query info for CRTC with <span class="Code_Char">drmModeGetCrtc()</span>.</div><div id="wwpID0EIHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>7.	</span></span>If necessary, set the mode with <span class="Code_Char">drmModeSetCrtc()</span>. Obtain the layer for the plane/CRTC.</div><div id="wwpID0EHHA" class="List_Continue">Use CRTC to drive the selected connector with a call to <span class="Code_Char">drmModeSetCrtc()</span>.</div><div id="wwpID0EGHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>8.	</span></span>If a plane must be used, set it with <span class="Code_Char">drmModeSetPlane()</span>.</div><div id="wwpID0EFHA" class="Heading_5">More information</div><div id="wwpID0EEHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>For API details, see “DRM API” in <span class="Emphasis">NVIDIA Jetson Linux API Reference</span>.</div><div id="wwpID0EDHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Ask your NVIDIA Customer Engineer for a sample implementation, <span class="Code_Char">window_egldevice.zip</span>.</div><H3 id="wwpID0ECHA" class="Heading_3">Board-to-Display Connectors</H3><div id="wwpID0EBHA" class="Body_Text">For information about the connectors on your platform and the relationship between connectors and displays, see the documentation for your hardware.</div></div><div id="page_dates"></div><!-- Related Topics --><!--                --><footer><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer></div></div><input type="hidden" id="preserve_unknown_file_links" value="false"></input><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></body></html>