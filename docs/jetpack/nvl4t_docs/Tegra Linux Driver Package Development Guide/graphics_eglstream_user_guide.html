<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><!-- NVIDIA customization --><title>NVIDIA Jetson Linux Driver Package Software Features : Graphics Programming | NVIDIA Docs </title><link rel="Prev" href="graphics_egldevice.html" title="Previous" /><link rel="Next" href="graphics_opengl.html" title="Next" /><link rel="StyleSheet" href="../css/font-awesome/css/font-awesome.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/graphics_eglstream_user_guide.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><noscript><div id="noscript_padding"></div></noscript></head><body id="po_002b9szSzdnBB8TJ88MlYWWw" class="ww_skin_page_body" style="visibility: hidden;"><input type="hidden" id="page_onload_url" value="../index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html"></input><span id="dropdown_ids" style="display:none;"></span><div id="ww_content_container"><header id="wwconnect_header"><div class="ww_skin_page_toolbar"><div id="dropdown_button_container" class="dropdown_container dropdown_button_container_disabled"><a id="show_hide_all" class="ww_skin ww_behavior_dropdown_toggle ww_skin_dropdown_toggle" title="Page DropDown Toggle" href="#"><i class="fa"></i></a><span class="ww_skin_page_toolbar_divider">&nbsp;</span></div><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#"><i class="fa"></i></a></div><!-- was this helpful button --><!--                         --></header><div id="page_content_container" style="background-attachment: scroll; background-image: url(&quot;watermark.png&quot;); background-position: center center; background-repeat: no-repeat; margin-left: 0pt; margin-right: 10pt; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px"><div id="page_content"><H1 id="wwpID0E0GE0HA" class="Heading_2_Top">EGLStream</H1><div class="WebWorks_MiniTOC"><div class="WebWorks_MiniTOC_Heading">&nbsp;</div><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0DE0HA">EGLStream Producers</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E05D0HA">EGLStream Consumers</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0YD0HA">EGLStream Operation Modes</a></div></dd><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0WD0HA">Mailbox Mode</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0TD0HA">FIFO Mode</a></div></dd></dl><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0QD0HA">EGLStream Pipeline</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0HB0HA">Building a Cross-Process EGLStream Pipeline</a></div></dd><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/graphics_eglstream_user_guide.html#wwpID0E0BB0HA">Cross-Process EGLStream Example</a></div></dd></dl></dl></div><div id="wwpID0E0FE0HA" class="Body_Text">EGLStream is a mechanism that efficiently transfers a sequence of image frames from one API to another, e.g., from OpenGL to CUDA.</div><div id="wwpID0E0EE0HA" class="Body_Text">In EGLStream architecture a producer and a consumer are attached to each end of a stream object. A <span class="Strong">producer</span> adds image frames to the stream. A <span class="Strong">consumer</span> retrieves image frames from the stream.</div><H3 id="wwpID0E0DE0HA" class="Heading_3">EGLStream Producers</H3><div id="wwpID0E0CE0HA" class="Body_Text">An EGLStream producer posts EGL image frames to an EGLStream. The producer is responsible for inserting each image frame into the EGLStream at the correct time so that the consumer can display the image frame for the appropriate period of time.</div><div id="wwpID0E0BE0HA" class="Body_Text">There are two types of producers:</div><div id="wwpID0E0AE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Strong">CUDA producers</span> post a CUDA array or CUDA pointer to the EGLStream as EGL image frames.</div><div id="wwpID0E06D0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Strong">OpenGL producers</span> post graphic surfaces to the EGLStream as EGL image frames.</div><H3 id="wwpID0E05D0HA" class="Heading_3">EGLStream Consumers</H3><div id="wwpID0E04D0HA" class="Body_Text">An EGLStream consumer retrieves EGL image frames from the EGLStream. The consumer is responsible for noticing that an image frame is available and displaying it (or otherwise consuming it). The consumer is responsible for the latency of the acquired frame (the time elapsed between image frame retrieval and display).</div><div id="wwpID0E03D0HA" class="Body_Text">There are three types of consumers:</div><div id="wwpID0E02D0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Strong">CUDA consumers</span> retrieve EGL image frames and deliver the frame information as a CUDA array or a CUDA pointer. The CUDA frames can then be processed in the CUDA domain.</div><div id="wwpID0E01D0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Strong">OpenGL consumers</span> retrieve EGL image frames that can then be bound as OpenGL textures for graphics rendering.</div><div id="wwpID0E0ZD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Strong">EGLOutput consumers</span> (EGLDevice window system only) retrieve EGL image frames and render them directly to EGLOutput. An EGLOutput consumer is applicable when EGLOutput is used on the EGLDevice window system.</div><H3 id="wwpID0E0YD0HA" class="Heading_3">EGLStream Operation Modes</H3><div id="wwpID0E0XD0HA" class="Body_Text">EGLStream operates in one of two modes: mailbox mode and FIFO mode.</div><H4 id="wwpID0E0WD0HA" class="Heading_4">Mailbox Mode</H4><div id="wwpID0E0VD0HA" class="Body_Text">In <span class="Strong">mailbox mode</span>, EGLStream conceptually operates as a mailbox. When the producer has a new image frame it empties the mailbox (discards the old contents) and inserts the new image frame into the mailbox. The consumer retrieves the image frame from the mailbox and examines it. When the consumer is finished examining the image frame, it either puts the frame back in the mailbox (if the mailbox is empty) or discards it (if the mailbox is not empty).</div><div id="wwpID0E0UD0HA" class="Body_Text">Timing is mainly controlled by the producer. The consumer operates with a fixed latency that it indicates to the producer through the EGLStream attribute <span class="Code_Char">EGL_CONSUMER_LATENCY_USEC_KHR</span>. The consumer must notice when a new image frame is available in the EGLStream, retrieve it, and display it in the time indicated by <span class="Code_Char">EGL_CONSUMER_LATENCY_USEC_KHR</span>. The producer controls when the image frame is displayed by inserting it into the stream at time <span class="Emphasis">t</span>&nbsp;−&nbsp;<span class="Code_Char">EGL_CONSUMER_LATENCY_USEC_KHR</span>, where <span class="Emphasis">t</span> is the time when the image frame is to be displayed.</div><H4 id="wwpID0E0TD0HA" class="Heading_4">FIFO Mode</H4><div id="wwpID0E0SD0HA" class="Body_Text">In <span class="Strong">FIFO mode</span> images are not discarded. When a producer adds image frames to the stream they go in a FIFO queue for subsequent retrieval by the consumer. EGLStream sets the queue size when it creates the queue. If the producer attempts to insert a frame and the queue is full, the producer blocks until there is room in the queue. When the consumer retrieves an image frame from the EGLStream, it gets the image frame that immediately follows the image frame last retrieved (unless no such frame has been inserted yet, in which case it retrieves the same image frame as last time).</div><div id="wwpID0E0RD0HA" class="Body_Text">Timing of an EGLStream in FIFO mode is the responsibility of the consumer. Each image frame in the queue has a timestamp set by the producer. The consumer uses this timestamp to determine when the image frame is intended to be displayed.</div><H3 id="wwpID0E0QD0HA" class="Heading_3">EGLStream Pipeline</H3><div id="wwpID0E0PD0HA" class="Body_Text">EGL provides functions to create and destroy EGLStreams, to query and set attributes of EGLStreams, and to connect EGLStreams to producers and consumers.</div><div id="wwpID0E0OD0HA" class="Body_Text">An EGLStream cannot be used until it is connected to a consumer and then to a producer. It must be connected to the consumer first.</div><div id="wwpID0E0ND0HA" class="Body_Text">An EGLStream may be connected to only one producer and one consumer. Once it is connected to a producer or a consumer, it remains connected to that entity until it is destroyed.</div><div id="wwpID0E0MD0HA" class="Heading_5">To build a simple EGLStream pipeline</div><div id="wwpID0E0LD0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Create the EGLDisplay object which the EGLStream is to bind to.</div><div id="wwpID0E0KD0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Call <span class="Code_Char">eglInitialize()</span> to initialize EGL on the display.</div><div id="wwpID0E0JD0HA" class="List_Continue">To use the OpenGL consumer or EGLOutput consumer, you must initialize the rendering window before you create the EGLStream pipeline.</div><div id="wwpID0E0ID0HA" class="List_Continue">To use the CUDA producer-consumer, window system initialization is not required.</div><div id="wwpID0E0HD0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Create an EGLStream.</div><div id="wwpID0E0GD0HA" class="List_Continue">This example of creating the EGLStream is from <span class="Code_Char">eglstreamcube.c</span>:</div><div id="wwpID0E0FD0HA" class="Code">client-&gt;stream = eglCreateStreamKHR(demoState.display, streamAttr);</div><div id="wwpID0E0ED0HA" class="Code">if (client-&gt;stream == EGL_NO_STREAM_KHR) {</div><div id="wwpID0E0DD0HA" class="Code">    NvGlDemoLog("Couldn't create EGL stream.\n");</div><div id="wwpID0E0CD0HA" class="Code">    goto fail;</div><div id="wwpID0E0BD0HA" class="Code">}</div><div id="wwpID0E0AD0HA" class="List_Continue">Set <span class="Code_Char">streamAttr</span> according to whether you are using mailbox mode or FIFO mode. For FIFO mode, the attribute <span class="Code_Char">EGL_STREAM_FIFO_LENGTH_KHR</span> is initialized:</div><div id="wwpID0E06C0HA" class="Code">if (demoOptions.nFifo &gt; 0) {</div><div id="wwpID0E05C0HA" class="Code">    streamAttr[numAttrs++] = EGL_STREAM_FIFO_LENGTH_KHR;</div><div id="wwpID0E04C0HA" class="Code">    streamAttr[numAttrs++] = demoOptions.nFifo;</div><div id="wwpID0E03C0HA" class="Code">}</div><div id="wwpID0E02C0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Create a consumer of the appropriate type and connect it to the EGLStream.</div><div id="wwpID0E01C0HA" class="List_Continue">This example of connecting an OpenGL consumer to the EGLStream is from <span class="Code_Char">eglstreamcube.c</span>:</div><div id="wwpID0E0ZC0HA" class="Code">glBindTexture(GL_TEXTURE_EXTERNAL_OES, texture);</div><div id="wwpID0E0YC0HA" class="Code">if (!eglStreamConsumerGLTextureExternalKHR(demoState.display, client-&gt;stream)) {</div><div id="wwpID0E0XC0HA" class="Code">    NvGlDemoLog("Couldn't bind texture.\n");</div><div id="wwpID0E0WC0HA" class="Code">    goto fail;</div><div id="wwpID0E0VC0HA" class="Code">}</div><div id="wwpID0E0UC0HA" class="List_Continue">Remember that once an EGLStream is connected to a consumer, it remains connected to that consumer until the EGLStream is destroyed.</div><div id="wwpID0E0TC0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Create a producer of the appropriate type and connect it to the EGLStream.</div><div id="wwpID0E0SC0HA" class="List_Continue">This example of connecting an OpenGL producer to the EGLStream is from <span class="Code_Char">nvgldemo_main.c</span>:</div><div id="wwpID0E0RC0HA" class="Code">eglCreateStreamProducerSurfaceKHR(demoState.display,</div><div id="wwpID0E0QC0HA" class="Code">                                  demoState.config,</div><div id="wwpID0E0PC0HA" class="Code">                                  demoState.stream,</div><div id="wwpID0E0OC0HA" class="Code">                                  srfAttrs);</div><div id="wwpID0E0NC0HA" class="List_Continue">Remember that once an EGLStream is connected to a producer, it remains connected to that producer until the EGLStream is destroyed.</div><div id="wwpID0E0MC0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>6.	</span></span>The producer posts the image frames (the stream) to the consumer in order, depending on the type of stream (FIFO or mailbox).</div><div id="wwpID0E0LC0HA" class="List_Continue">In the OpendGL producer case, <span class="Code_Char">eglSwapBuffers()</span> posts the buffer to the consumer.</div><div id="wwpID0E0KC0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>7.	</span></span>The consumer acquires the image frame posted by the producer, uses it, and then releases the frame back to the stream. Methods for acquiring frames from a stream and releasing them back to a stream are dependent on the type of consumer.</div><div id="wwpID0E0JC0HA" class="List_Continue">This example of acquiring and releasing the frame in the OpenGL consumer case is from <span class="Code_Char">eglstreamcube.c</span>:</div><div id="wwpID0E0IC0HA" class="Code">eglStreamConsumerAcquireKHR(demoState.display,</div><div id="wwpID0E0HC0HA" class="Code">                            clientList[i].stream)</div><div id="wwpID0E0GC0HA" class="Code">eglStreamConsumerReleaseKHR(demoState.display,</div><div id="wwpID0E0FC0HA" class="Code">                            client-&gt;stream)</div><div id="wwpID0E0EC0HA" class="List_Continue">In the OPENGL consumer case, if the application calls <span class="Code_Char">eglStreamConsumerAcquireKHR()</span>twice on the same EGLStream without an intervening call to <span class="Code_Char">eglStreamConsumerReleaseKHR()</span>, then <span class="Code_Char">eglStreamConsumerReleaseKHR()</span> is implicitly called at the start of <span class="Code_Char">eglStreamConsumerAcquireKHR()</span>.</div><div id="wwpID0E0DC0HA" class="Heading_5">To destroy the EGLStream pipeline</div><div id="wwpID0E0CC0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Destroy the producer.</div><div id="wwpID0E0BC0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Destroy the consumer.</div><div id="wwpID0E0AC0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Destroy the EGLStream.</div><div id="wwpID0E06B0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Destroy the window system resources.</div><div id="wwpID0E05B0HA" class="Body_Text">The application must destory resources in this order to produce a correct result.</div><div id="wwpID0E04B0HA" class="Heading_5">EGLStream State</div><div id="wwpID0E03B0HA" class="Body_Text">At any time after an EGLStream is created, it is in one of these states:</div><div id="wwpID0E02B0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_CREATED_KHR</span>: Created but not yet connected to a producer or a consumer.</div><div id="wwpID0E01B0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_CONNECTING_KHR</span>: Connected to a consumer but not yet connected to a producer.</div><div id="wwpID0E0ZB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_EMPTY_KHR</span>: Connected to a consumer and a producer, but the producer has not yet posted any image frames.</div><div id="wwpID0E0YB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR</span>: The producer has posted at least one image frame that the consumer has not yet acquired.</div><div id="wwpID0E0XB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR</span>: The producer has posted at least one image frame, and the consumer has acquired the most recently posted image frame.</div><div id="wwpID0E0WB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_DISCONNECTED_KHR</span>: The producer, the consumer, or both are no longer connected to the EGLStream, i.e., they have been destroyed. Once the EGLStream is in this state it remains in this state until it is destroyed. In this state the only valid operations on the EGStream are <span class="Code_Char">eglQueryStreamKHR()</span> and <span class="Code_Char">eglDestroyStreamKHR()</span>.</div><div id="wwpID0E0VB0HA" class="Body_Text">You query the EGLStream’s state like this:</div><div id="wwpID0E0UB0HA" class="Code">EGLBoolean  eglQueryStreamKHR(</div><div id="wwpID0E0TB0HA" class="Code">            EGLDisplay    dpy,</div><div id="wwpID0E0SB0HA" class="Code">            EGLStreamKHR  stream,</div><div id="wwpID0E0RB0HA" class="Code">            EGLenum       attribute,</div><div id="wwpID0E0QB0HA" class="Code">            EGLuint64KHR *value);</div><div id="wwpID0E0PB0HA" class="Body_Text">These state transitions can occur:</div><div id="wwpID0E0OB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_CREATED_KHR</span>: The initial state, of an EGLStream that has just been created.</div><div id="wwpID0E0NB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_CREATED_KHR</span> to <span class="Code_Char">EGL_STREAM_STATE_CONNECTING_KHR</span>: Occurs when a consumer is connected to the EGLStream.</div><div id="wwpID0E0MB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_CONNECTING_KHR</span> to <span class="Code_Char">EGL_STREAM_STATE_EMPTY_KHR</span>: Occurs when a producer is connected to the EGLStream.</div><div id="wwpID0E0LB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_EMPTY_KHR</span> to <span class="Code_Char">EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR</span>: Occurs the first time the producer inserts an EGL image frame.</div><div id="wwpID0E0KB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR</span> to <span class="Code_Char">EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR</span>: Occurs when the consumer begins acquiring a newly posted EGL image frame.</div><div id="wwpID0E0JB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">EGL_STREAM_STATE_OLD_FRAME_AVAILABLE_KHR</span> to <span class="Code_Char">EGL_STREAM_STATE_NEW_FRAME_AVAILABLE_KHR</span>: Occurs when the producer posts a new EGL image frame.</div><div id="wwpID0E0IB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Any state to <span class="Code_Char">EGL_STREAM_STATE_DISCONNECTED_KHR</span>: Occurs when the producer or consumer is destroyed.</div><H3 id="wwpID0E0HB0HA" class="Heading_3">Building a Cross-Process EGLStream Pipeline</H3><div id="wwpID0E0GB0HA" class="Body_Text">A cross-process EGLStream is one whose producer and consumer are in different processes.</div><div id="wwpID0E0FB0HA" class="Heading_5">To build a cross-process EGLStream pipeline</div><div id="wwpID0E0EB0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>The consumer process creates an EGLStream.</div><div id="wwpID0E0DB0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>The consumer process gets the file descriptor for the EGLStream and sends it through the socket to the producer process.</div><div id="wwpID0E0CB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>In the producer process, the producer receives the file descriptor through the socket and creates a corresponding EGLStream from the file descriptor. After the EGLStreams are created in both consumer and producer processes, the consumer and the producer are created and are connected to the EGLStreams, and through them, to each other.</div><H4 id="wwpID0E0BB0HA" class="Heading_4">Cross-Process EGLStream Example</H4><div id="wwpID0E0AB0HA" class="Body_Text">L4T provides a pair of sample applications that constitute an example of communication through a cross-process EGLStream pipeline:</div><div id="wwpID0E6HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">samples/opengles2/eglstreamcube</span> is the consumer.</div><div id="wwpID0E5HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">samples/opengles2/bubble</span> is the producer.</div><div id="wwpID0E4HA" class="Body_Text">You can demonstrate communication through a cross-process EGLStream pipeline by starting the consumer, then the producer</div><div id="wwpID0E3HA" class="Body_Text">The consumer application performs these operations:</div><div id="wwpID0E2HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Creates the stream and get the file descriptor of the stream (see <span class="Code_Char">eglstreamcube.c</span>):</div><div id="wwpID0E1HA" class="Code">client-&gt;stream = eglCreateStreamKHR(demoState.display,     streamAttr);</div><div id="wwpID0EZHA" class="Code">client-&gt;fd = eglGetStreamFileDescriptorKHR(demoState.display, client-&gt;stream);</div><div id="wwpID0EYHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Shares the file descriptor with the producer through the socket.</div><div id="wwpID0EXHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Binds the consumer end of the EGLStream with the OPENGL texture (see <span class="Code_Char">eglstreamcube.c</span>).</div><div id="wwpID0EWHA" class="Code">glBindTexture(GL_TEXTURE_EXTERNAL_OES, texture);</div><div id="wwpID0EVHA" class="Code">eglStreamConsumerGLTextureExternalKHR(demoState.display, client-&gt;stream)</div><div id="wwpID0EUHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Latches the most recent image frame to the texture with <span class="Code_Char">eglStreamConsumerAcquireKHR()</span>:</div><div id="wwpID0ETHA" class="Code">eglStreamConsumerAcquireKHR(demoState.display,stream)</div><div id="wwpID0ESHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Renders the texture as one face of the cube.</div><div id="wwpID0ERHA" class="Body_Text">The producer application performs these operations:</div><div id="wwpID0EQHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Receives the stream file descriptor through the socket (specified by a ‑<span class="Code_Char">eglstreamsocket</span> option) and create the stream (see <span class="Code_Char">nvgldemo_main.c</span>):</div><div id="wwpID0EPHA" class="Code">eglCreateStreamFromFileDescriptorKHR(demoState.display, fd)</div><div id="wwpID0EOHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Creates the EGLStream surface (refer to <span class="Code_Char">nvgldemo_main.c</span>).</div><div id="wwpID0ENHA" class="Code">eglCreateStreamProducerSurfaceKHR(</div><div id="wwpID0EMHA" class="Code">                    demoState.display,</div><div id="wwpID0ELHA" class="Code">                    demoState.config,</div><div id="wwpID0EKHA" class="Code">                    demoState.stream,</div><div id="wwpID0EJHA" class="Code">                    srfAttrs)</div><div id="wwpID0EIHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Creates an instance <span class="Code_Char">EGLContext</span> and binds it to the thread by calling <span class="Code_Char">eglMakeCurrent()</span> on the EGLStream surface created in step 2.</div><div id="wwpID0EHHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Starts rendering the frames and eglSwapBuffers.</div><div id="wwpID0EGHA" class="Heading_5">To run the cross-process EGLStream pipeline example</div><div id="wwpID0EFHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Enter this command to start the consumer application:</div><div id="wwpID0EEHA" class="Code">./eglstreamcube -dispno 1 -layer 1 -windowoffset 1000 0 -socket /tmp/test &amp;</div><div id="wwpID0EDHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Enter this command to start the producer application:</div><div id="wwpID0ECHA" class="Code">./bubble -eglstreamsocket /tmp/test &amp;</div><div id="wwpID0EBHA" class="Body_Text">The <span class="Code_Char">bubble</span> application content appears on one face of the cube.</div></div><div id="page_dates"></div><!-- Related Topics --><!--                --><footer><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer></div></div><input type="hidden" id="preserve_unknown_file_links" value="false"></input><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></body></html>