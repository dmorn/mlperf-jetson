<!DOCTYPE html ><html xml:lang="en" lang="en" data-highlight-require-whitespace="false" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><!-- NVIDIA customization --><title>NVIDIA Jetson Linux Driver Package Software Features : Security | NVIDIA Docs </title><link rel="Prev" href="trusty.html" title="Previous" /><link rel="Next" href="kernel_custom.html" title="Next" /><link rel="StyleSheet" href="../css/font-awesome/css/font-awesome.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/bootloader_disk_encryption.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/social.css" type="text/css" media="all" /><link rel="StyleSheet" href="css/print.css" type="text/css" media="print" /><noscript><div id="noscript_padding"></div></noscript></head><body id="pYzDZ1SvuqOGMJt5XcUbYDg" class="ww_skin_page_body" style="visibility: hidden;"><input type="hidden" id="page_onload_url" value="../index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html"></input><span id="dropdown_ids" style="display:none;"></span><div id="ww_content_container"><header id="wwconnect_header"><div class="ww_skin_page_toolbar"><div id="dropdown_button_container" class="dropdown_container dropdown_button_container_disabled"><a id="show_hide_all" class="ww_skin ww_behavior_dropdown_toggle ww_skin_dropdown_toggle" title="Page DropDown Toggle" href="#"><i class="fa"></i></a><span class="ww_skin_page_toolbar_divider">&nbsp;</span></div><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#"><i class="fa"></i></a></div><!-- was this helpful button --><!--                         --></header><div id="page_content_container" style="background-attachment: scroll; background-image: url(&quot;watermark.png&quot;); background-position: center center; background-repeat: no-repeat; margin-left: 0pt; margin-right: 10pt; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px"><div id="page_content"><H1 id="wwpID0E05F0HA" class="Heading_2_Top">Disk Encryption</H1><div class="WebWorks_MiniTOC"><div class="WebWorks_MiniTOC_Heading">&nbsp;</div><dl class="WebWorks_MiniTOC_List"><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0E02F0HA">Setup Preparation</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0E0XF0HA">Details of Operation</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0E0NE0HA">The Threat Model</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0E0IE0HA">Disk Encryption Implementation in Jetson Linux</a></div></dd><dd><div class="WebWorks_MiniTOC_Entry"><a class="WebWorks_MiniTOC_Link" href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0EFHA">Manufacturing process</a></div></dd></dl></div><div id="wwpID0E04F0HA" class="Body_Text_Indent"><span class="Strong">Applies to</span>: Jetson Xavier NX, Jetson AGX Xavier series, and Jetson TX2 series</div><div id="wwpID0E03F0HA" class="Body_Text">Disk encryption encrypts a whole disk or partition to protect the data it contains. Jetson Linux offers disk encryption that is based on <span class="Strong">Linux Unified Key Setup</span> (LUKS) <span class="Hyperlink"><a href="https://wiki.archlinux.org/index.php/disk_encryption" target="external_window">Data-at-rest encryption</a></span>, the standard for Linux disk encryption. It provides a standard disk format that stores all necessary setup information on the disk itself, in the partition header. The passphrase in the Trusty architecture supports disk encryption functionality with multiple user passwords.</div><H3 id="wwpID0E02F0HA" class="Heading_3">Setup Preparation</H3><div id="wwpID0E01F0HA" class="Body_Text">Jetson Linux uses <span class="Code_Char">cryptsetup,</span> a LUKS userspace command line utility, to set up and unlock an encrypted disk. It uses the <span class="Code_Char">DMCrypt</span> kernel module as its backend. The utility sets up the encrypted disk as a LUKS partition and configures it with a passphrase.</div><div id="wwpID0E0ZF0HA" class="Body_Text">The <span class="Code_Char">DMCrypt</span> kernel module is the standard device-mapper interface for encryption functionality in the Linux kernel. It sits between the disk driver and the file system, where it encrypts and decrypts data blocks transparently.</div><div id="wwpID0E0YF0HA" class="Body_Text">For more information about <span class="Code_Char">cryptsetup</span> and <span class="Code_Char">e</span>, see the <span class="Hyperlink"><a href="https://gitlab.com/cryptsetup/cryptsetup" target="external_window">cryptsetup project</a></span> and the <span class="Hyperlink"><a href="https://gitlab.com/cryptsetup/cryptsetup/-/wikis/DMCrypt" target="external_window">DMCrypt documentation</a></span>, both hosted by GitLab.</div><H3 id="wwpID0E0XF0HA" class="Heading_3">Details of Operation</H3><div id="wwpID0E0WF0HA" class="Body_Text">Two types of keys are used for disk encryption:</div><div id="wwpID0E0VF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The <span class="Strong">master key</span>, also known as the <span class="Strong">Disk Encryption Key</span> (DEK). This key is used for data encryption or decryption when data is transferred between the filesystem and the disk.</div><div id="wwpID0E0UF0HA" class="List_Continue">The master key is generated by <span class="Code_Char">cryptsetup</span>. The default and recommended source for data used to generate the key is <span class="Code_Char">/dev/random</span>. The key resides in the LUKS header, and is encrypted by the key derived from the passphrase.</div><div id="wwpID0E0TF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The <span class="Strong">passphrase</span> or <span class="Strong">password</span> is an input string or pattern supplied by the user to set up disk encryption and lock the disk. The same input is used to decrypt and unlock data stored on the disk.</div><div id="wwpID0E0SF0HA" class="Body_Text">The passphrase is generated with help from two applications:</div><div id="wwpID0E0RF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">luks-srv</span>: is a TA that queries the EKB key and uses it to derive a LUKS key, which is the root key for deriving the passphrase.</div><div id="wwpID0E0QF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">nvluks-srv-app</span> is a CA in the normal (non-secure) world that communicates with <span class="Code_Char">luks-srv</span> to retrieve the passphrase. <span class="Code_Char">cryptsetup</span> uses the passphrase to unlock the encrypted disk.</div><div id="wwpID0E0PF0HA" class="Body_Text">The cryptographic algorithm used for disk encryption is AES-CBC with ESSIV, use a key length of 128 bits. This mode of operation makes the encrypted data look completely random, minimizing the potential for attack. The entire key derivation process is performed in the secure world. The following diagram outlines the process:</div><div class="ww_skin_page_overflow"><div id="wwpID0E0OF0HA" class="Body_Text"><img class="Default" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/image1_3.png" style="display: inline; left: 0pt; top: 0pt" alt="Diagram Description automatically generated" title="Diagram Description automatically generated" /></div></div><div id="wwpID0E0NF0HA" class="Body_Text">The generation process uses this <span class="Strong">key derivation function</span> (KDF) to generate a per-device unique LUKS key or a generic key:</div><div class="ww_skin_page_overflow"><div id="wwpID0E0MF0HA" class="Normal"><img class="Equation" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/bootloader_disk_encryption.1.2.jpg" width="100%" style="display: block; left: 0pt; max-height: 18px; max-width: 397px; top: 0pt" alt="" title="" /></div></div><div id="wwpID0E0LF0HA" class="Body_Text">Where:</div><div id="wwpID0E0KF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Hyperlink"><a href="https://csrc.nist.gov/publications/detail/sp/800-108/final" target="external_window">NIST-SP-800-108</a></span> is a <span class="Strong">key derivation function</span> (KDF) recommended by the National Institute of Standards and Technology algorithm for key derivation using pseudorandom functions..</div><div id="wwpID0E0JF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Emphasis">in-key </span>is a string from which the key is derived. In the L4T implementation it is the EKB key.</div><div id="wwpID0E0IF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Emphasis">label-string</span> identifies the purpose of the key to be generated. In the reference implementation <span class="Emphasis">label-string</span> is a fixed value defined by the TA.</div><div id="wwpID0E0HF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Emphasis">context-string</span> is a string that contains information related to the derived key, and which the KDF uses as a parameter for key generation. In the reference implementation the default context string is the disk’s UUID, but you can change this by modifying the TA.</div><div id="wwpID0E0GF0HA" class="Body_Text">To generate a per-device unique LUKS key, <span class="Emphasis">label-string</span> is <span class="Code_Char">"luks-srv-ecid"</span> and <span class="Emphasis">context‑string</span> is <span class="Code_Char">"$(ECID)"</span> (a reference to the environment variable <span class="Code_Char">ECID</span>).</div><div id="wwpID0E0FF0HA" class="Body_Text">To generate a generic key, <span class="Emphasis">label-string</span> is <span class="Code_Char">"luks-srv-generic"</span>. and <span class="Emphasis">context‑string</span> is <span class="Code_Char">"generic-key"</span>.</div><div id="wwpID0E0EF0HA" class="Body_Text">Once the LUKS key is created, the <span class="Code_Char">nvluks-srv-app</span> CA from the normal world can query the <span class="Code_Char">luks-srv</span> TA to obtain the passphrase. </div><div class="ww_skin_page_overflow"><div id="wwpID0E0DF0HA" class="Body_Text"><img class="Default" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/image2_7.png" style="display: inline; left: 0pt; top: 0pt" alt="Diagram Description automatically generated" title="Diagram Description automatically generated" /></div></div><div id="wwpID0E0CF0HA" class="Body_Text">The <span class="Code_Char">nvluks-srv-app</span> CA communicates with the TA by sending it an IPC packet . This is the packet’s structure:</div><div id="wwpID0E0BF0HA" class="Code">typedef struct luks_srv_cmd_msg {</div><div id="wwpID0E0AF0HA" class="Code">    uint32_t luks_srv_cmd;</div><div id="wwpID0E06E0HA" class="Code">    char context_str[40[;</div><div id="wwpID0E05E0HA" class="Code">    char output_passphrase[16];</div><div id="wwpID0E04E0HA" class="Code">{ luks_src_cmd_msg_t;</div><div id="wwpID0E03E0HA" class="Body_Text">The packet’s data members are:</div><div id="wwpID0E02E0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">luks_srv_cmd</span> is the command message that tells the TA what to do with the packet. <span class="Code_Char">LUKS_GET_UNIQUE_PASS</span> tells the TA to generate a per-device unique passphrase; <span class="Code_Char">LUKS_GET_GENERIC_PASS</span> tells it to generate a generic one.</div><div id="wwpID0E01E0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">context_str</span> is the context string passed to the KDF to generate the passphrase. In this implementation the input context string is the disk UUID, so no user interaction is needed to create the encrypted disk image or to unlock it at boot time.</div><div id="wwpID0E0ZE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">output_passphrase</span> is the passphrase returned by the TA. With the output passphrase from <span class="Code_Char">nvluks-srv-app</span>, it can be used to unlock the encrypted disk.</div><div id="wwpID0E0YE0HA" class="Body_Text">This example shows how to unlock the encrypted disk with <span class="Code_Char">nvluks-srv-app</span>.</div><div id="wwpID0E0XE0HA" class="Code">#!/bin/bash</div><div id="wwpID0E0WE0HA" class="Code">&nbsp;</div><div id="wwpID0E0VE0HA" class="Code"># Using "cryptsetup" and "nvluks-srv-app" to unlock the encrypted device:</div><div id="wwpID0E0UE0HA" class="Code">nvluks-srv-app --context-string “${UUID}” \</div><div id="wwpID0E0TE0HA" class="Code">        --get-unique-pass | \</div><div id="wwpID0E0SE0HA" class="Code">        cryptsetup -c aes-cbc-essiv:sha256 \</div><div id="wwpID0E0RE0HA" class="Code">        -s 128 \</div><div id="wwpID0E0QE0HA" class="Code">        luksOpen \</div><div id="wwpID0E0PE0HA" class="Code">        &lt;luksDevice&gt; &lt;DM_name&gt;</div><div class="ww_skin_page_overflow"><table class="Table_Normal" style="margin-left: 54pt" cellspacing="0" summary=""><tr><td style="background-color: #76B900; background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top; width: 49.5pt"><div id="wwpID0EABA0OE0HA" class="Note_Image">Note:</div></td><td style="background-color: #DDEEBF; background-position: right center; border-bottom-color: Silver; border-bottom-style: solid; border-bottom-width: thin; border-left-color: Silver; border-left-style: solid; border-left-width: thin; border-right-color: Silver; border-right-style: solid; border-right-width: thin; border-top-color: Silver; border-top-style: solid; border-top-width: thin; padding-bottom: 3pt; padding-left: 3pt; padding-right: 3pt; padding-top: 3pt; vertical-align: top; width: 315pt"><div id="wwpID0EAAA0OE0HA" class="Note_Text">To prevent any form of attack from extracting the passphrase at boot time (e.g. in the initrd), use the <span class="Code_Char">luks_srv_cmd</span> command type <span class="Code_Char">LUKS_NO_PASS_RESPONSE</span>. This command instructs <span class="Code_Char">luks-srv</span> not to respond to a <span class="Code_Char">LUKS_GET</span> command (to get the passphrase) until reboot. This step is crucial to ensure the security of your design.</div></td></tr></table></div><H3 id="wwpID0E0NE0HA" class="Heading_3">The Threat Model</H3><div id="wwpID0E0ME0HA" class="Body_Text">The purpose of disk encryption is to prevent an attack from stealing or tampering with data on the disk. Even if the disk is physically unmounted (or, in the case of an internal device such as an eMMC, is removed from the device), the data cannot be exposed.</div><div id="wwpID0E0LE0HA" class="Body_Text">Disk encryption cannot protect against the following types of threat:</div><div id="wwpID0E0KE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>A background process or daemon that has a security hole. An attacker may be able to use the hole to gain control of the process and access the disk.</div><div id="wwpID0E0JE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>Theft or leakage of the login ID and password. An attacker can use these credentials to log in to the device and access the disk.</div><H3 id="wwpID0E0IE0HA" class="Heading_3">Disk Encryption Implementation in Jetson Linux</H3><div id="wwpID0E0HE0HA" class="Body_Text">Jetson Linux provides a reference implementation of disk encryption which fulfills the security requirements of many use cases. If your use case’s requirements are different, you can modify it or use it as a model for implementing your own.</div><div id="wwpID0E0GE0HA" class="Heading_5">Layout of an Encrypted Disk</div><div id="wwpID0E0FE0HA" class="Body_Text">Because the bootloader cannot read encrypted files, disk encryption requires L4T to divide a “naïve” system’s APP partition in two:</div><div id="wwpID0E0EE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The unencrypted APP partition contains the <span class="Code_Char">/boot</span> branch of the filesystem, including the kernel, DTB, and initrd images</div><div id="wwpID0E0DE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>A new, encrypted APP_ENC partition contains the rest of the filesystem.</div><div id="wwpID0E0CE0HA" class="List_Continue">Following is an example of the APP partition definition for a system on which disk encryption is not enabled. You can find a definition like this one in the L4T BSP partition configuration files, e.g<span class="Code_Char">. Linux_for_Tegra/‌bootloader/‌t186ref/cfg/‌flash_t194_sdmmc.xml</span> for a Jetson AGX Xavier™ series device booting from SDMMC memory..</div><div id="wwpID0E0BE0HA" class="Code">&lt;partition name="APP" type="data"&gt;</div><div id="wwpID0E0AE0HA" class="Code">    &lt;allocation_policy&gt; sequential &lt;/allocation_policy&gt;</div><div id="wwpID0E06D0HA" class="Code">    &lt;filesystem_type&gt; basic &lt;/filesystem_type&gt;</div><div id="wwpID0E05D0HA" class="Code">    &lt;size&gt; APPSIZE &lt;/size&gt;</div><div id="wwpID0E04D0HA" class="Code">    &lt;file_system_attribute&gt; 0 &lt;/file_system_attribute&gt;</div><div id="wwpID0E03D0HA" class="Code">    &lt;allocation_attribute&gt; 0x8 &lt;/allocation_attribute&gt;</div><div id="wwpID0E02D0HA" class="Code">    &lt;align_boundary&gt; 4096 &lt;/align_boundary&gt;</div><div id="wwpID0E01D0HA" class="Code">    &lt;percent_reserved&gt; 0 &lt;/percent_reserved&gt;</div><div id="wwpID0E0ZD0HA" class="Code">    &lt;filename&gt; APPFILE &lt;/filename&gt;</div><div id="wwpID0E0YD0HA" class="Code">    &lt;unique_guid&gt; APPUUID &lt;/unique_guid&gt;</div><div id="wwpID0E0XD0HA" class="Code">    &lt;description&gt;</div><div id="wwpID0E0WD0HA" class="Code">      **Required.** Contains the rootfs. This partition must be defined</div><div id="wwpID0E0VD0HA" class="Code">      after `primary_GPT` so that it can be accessed as the fixed known</div><div id="wwpID0E0UD0HA" class="Code">      special Device `/dev/mmcblk0p1`.</div><div id="wwpID0E0TD0HA" class="Code">    &lt;/description&gt;</div><div id="wwpID0E0SD0HA" class="Code">&lt;/partition&gt;</div><div id="wwpID0E0RD0HA" class="Body_Text">The following example shows how disk encryption separates APP into two partitions. You can find the file in the L4T BSP, e.g. <span class="Code_Char">Linux_for_Tegra/‌bootloader/‌t186ref/cfg/‌flash_t194_sdmmc_enc_rfs.xml</span> for the same device as above.</div><div id="wwpID0E0QD0HA" class="Code">&lt;partition name="APP" type="data"&gt;</div><div id="wwpID0E0PD0HA" class="Code">    &lt;allocation_policy&gt; sequential &lt;/allocation_policy&gt;</div><div id="wwpID0E0OD0HA" class="Code">    &lt;filesystem_type&gt; basic &lt;/filesystem_type&gt;</div><div id="wwpID0E0ND0HA" class="Code">    &lt;size&gt; <span style="color: #FF0000; font-weight: bold">104857600</span> &lt;/size&gt;</div><div id="wwpID0E0MD0HA" class="Code">    &lt;file_system_attribute&gt; 0 &lt;/file_system_attribute&gt;</div><div id="wwpID0E0LD0HA" class="Code">    &lt;allocation_attribute&gt; 0x8 &lt;/allocation_attribute&gt;</div><div id="wwpID0E0KD0HA" class="Code">    &lt;align_boundary&gt; 4096 &lt;/align_boundary&gt;</div><div id="wwpID0E0JD0HA" class="Code">    &lt;percent_reserved&gt; 0 &lt;/percent_reserved&gt;</div><div id="wwpID0E0ID0HA" class="Code">    &lt;filename&gt; <span style="color: #FF0000; font-weight: bold">system_boot.img</span> &lt;/filename&gt;</div><div id="wwpID0E0HD0HA" class="Code">    &lt;unique_guid&gt; APPUUID &lt;/unique_guid&gt;</div><div id="wwpID0E0GD0HA" class="Code">    &lt;description&gt;</div><div id="wwpID0E0FD0HA" class="Code">      **Required.** Contains the boot partition. This partition must be </div><div id="wwpID0E0ED0HA" class="Code">      defined after `primary_GPT` so that it can be accessed as the fixed </div><div id="wwpID0E0DD0HA" class="Code">      known special device `/dev/mmcblk0p1`.</div><div id="wwpID0E0CD0HA" class="Code">    &lt;/description&gt;</div><div id="wwpID0E0BD0HA" class="Code">&lt;/partition&gt;</div><div id="wwpID0E0AD0HA" class="Code">&nbsp;</div><div id="wwpID0E06C0HA" class="Code">&lt;partition name="<span style="color: #FF0000; font-weight: bold">APP_ENC</span>" type="data" <span style="color: #FF0000; font-weight: bold">encrypted=”true”</span>&gt;</div><div id="wwpID0E05C0HA" class="Code">    &lt;allocation_policy&gt; sequential &lt;/allocation_policy&gt;</div><div id="wwpID0E04C0HA" class="Code">    &lt;filesystem_type&gt; basic &lt;/filesystem_type&gt;</div><div id="wwpID0E03C0HA" class="Code">    &lt;size&gt; <span style="color: #FF0000; font-weight: bold">APP_ENC_SIZE</span> &lt;/size&gt;</div><div id="wwpID0E02C0HA" class="Code">    &lt;file_system_attribute&gt; 0 &lt;/file_system_attribute&gt;</div><div id="wwpID0E01C0HA" class="Code">    &lt;allocation_attribute&gt; 0x8 &lt;/allocation_attribute&gt;</div><div id="wwpID0E0ZC0HA" class="Code">    &lt;align_boundary&gt; 4096 &lt;/align_boundary&gt;</div><div id="wwpID0E0YC0HA" class="Code">    &lt;percent_reserved&gt; 0 &lt;/percent_reserved&gt;</div><div id="wwpID0E0XC0HA" class="Code">    &lt;filename&gt; <span style="color: #FF0000; font-weight: bold">system_root_encrypted.img</span> &lt;/filename&gt;</div><div id="wwpID0E0WC0HA" class="Code">    &lt;unique_guid&gt; <span style="color: #FF0000; font-weight: bold">APP_ENC_UUID</span> &lt;/unique_guid&gt;</div><div id="wwpID0E0VC0HA" class="Code">    &lt;description&gt;</div><div id="wwpID0E0UC0HA" class="Code">      **Required.** Contains the encrypted root partition.</div><div id="wwpID0E0TC0HA" class="Code">    &lt;/description&gt;</div><div id="wwpID0E0SC0HA" class="Code">&lt;/partition&gt;</div><div id="wwpID0E0RC0HA" class="Body_Text">The differences between the first example’s definition of <span class="Code_Char">APP</span> and the second example’s definitions of <span class="Code_Char">APP</span> and <span class="Code_Char">APP_ENC</span> are highlighted by red type. The elements in the <span class="Code_Char">APP_ENC</span> definition are the same as those in <span class="Code_Char">APP</span>.</div><div id="wwpID0E0QC0HA" class="Body_Text">Notice that the <span class="Code_Char">&lt;size&gt;</span> element of APP specifies an actual number, but the <span class="Code_Char">&lt;size&gt;</span> element of <span class="Code_Char">APP_ENC</span> specifies a symbol, <span class="Code_Char">APP_ENC_SIZE</span>. Later, the value of <span class="Code_Char">APP_ENC_SIZE</span> must be calculated by subtracting the size of <span class="Code_Char">APP</span> from the total rootfs size.</div><div id="wwpID0E0PC0HA" class="Body_Text">Each partition’s <span class="Code_Char">&lt;filename&gt;</span> element specifies the actual file name of the appropriate disk image (not a symbol that is resolved to the file name during flashing).</div><div id="wwpID0E0NC0HA" class="Body_Text">The partitions’ <span class="Code_Char">&lt;unique_guid&gt;</span> elements specify the partitions’ UUIDs, <span class="Code_Char">APPUUID</span> and <span class="Code_Char">APP_ENC_UUID</span> respectively. Both symbols are translated to real UUID numbers by the image generation process.</div><div id="wwpID0E0MC0HA" class="Body_Text">The <span class="Code_Char">APP_ENC</span> partition’s encrypted attribute indicates that the partition is encrypted.</div><div id="wwpID0E0LC0HA" class="Body_Text">With the new partition layout, new parameters are needed in the board configuration file to enable disk encryption and apply the new partition layout file. Use the appropriate board configuration file for your device, e,g<span class="Code_Char">, Linux_for_Tegra/p2972-0000.conf.common</span> for a Jetson AGX Xavier module in a Jetson AGX Xavier Developer Kit. The <span class="Code_Char">disk_enc_enable</span> setting indicates that disk encryption is enabled, and <span class="Code_Char">EMMC_CFG</span> identifies the partition layout file to use:</div><div id="wwpID0E0JC0HA" class="Code">disk_enc_enable=1;</div><div id="wwpID0E0IC0HA" class="Code">EMMC_CFG=flash_l4t_t194_sdmmc_enc_rfs.xml;</div><div id="wwpID0E0HC0HA" class="Body_Text">The flash tool uses the board configuration file to generate file system images and flash them onto the device.</div><div id="wwpID0E0GC0HA" class="Heading_5">How to Create File System Images</div><div id="wwpID0E0FC0HA" class="Body_Text">When you create file system images to support booting with an encrypted disk, keep the following points in mind:</div><div id="wwpID0E0EC0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The <span class="Code_Char">bootarg</span> kernel command line’s <span class="Code_Char">root</span> parameter must use the disk’s UUID (not the partition’s UUID specified in the partition definition) to identify the root disk if the device is to boot from an encrypted root disk.</div><div id="wwpID0E0DC0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The <span class="Code_Char">crypttab</span> file in initrd includes the mount point and the device name of the encrypted disk. It may be a real device name like <span class="Code_Char">/dev/mmcblk0p1</span> or the UUID of the disk.</div><div id="wwpID0E0CC0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span>The <span class="Code_Char">fstab</span> file in the rootfs is updated with the <span class="Code_Char">/boot</span> directory in the <span class="Code_Char">APP</span> partition. This helps the automount process to mount the partition at boot time.</div><div id="wwpID0E0BC0HA" class="Heading_5">How to Create an Encrypted Rootfs on the Host</div><div id="wwpID0E0AC0HA" class="Body_Text">The rootfs is generated on the host by <span class="Code_Char">flash.sh</span>. The diagram below shows the elements of the rootfs (in green), the utilities used to generate it (in blue), and the input (in red).</div><div class="ww_skin_page_overflow"><div id="wwpID0E06B0HA" class="Body_Text"><img class="Default" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/image3_6.png" style="display: inline; left: 0pt; top: 0pt" alt="Diagram Description automatically generated" title="Diagram Description automatically generated" /></div></div><div id="wwpID0E05B0HA" class="Body_Text">The input has two parts: the plain key file of the EKB key used for disk encryption, and an input string used to generate the passphrase. By default, the input string is the UUID of the encrypted disk. You can modify the script that generates the rootfs to let user to enter their own string. You must change the initrd accordingly to make it use the user-supplied string.</div><div id="wwpID0E04B0HA" class="Body_Text">You must generate the rootfs on a secure system, that is, a secure host computer equipped with a <span class="Strong">Hardware Security Module</span> (HSM). The HSM is used for key generation and management to secure key assets and safe transport to the factory floor. This is necessary to ensure that the keys cannot be leaked to an unsecure system on the production line. <span class="Code_Char">flash.sh</span> invokes two helper scripts to generate the passphrase and the disk images:</div><div id="wwpID0E03B0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">gen_luks_passphrase.py</span> follows the same process as the <span class="Code_Char">hwkey-agent</span> and <span class="Code_Char">luks-srv</span> TAs to derive the LUKS key, and uses the key to generate the passphrase.</div><div id="wwpID0E02B0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">disk_encryption.sh</span> outputs the disk images for the initrd, <span class="Code_Char">system_boot.img</span>, and <span class="Code_Char">system_root_encrypted.img</span>.</div><div id="wwpID0E01B0HA" class="Body_Text">The Jetson Linux reference implementation only generates per-device encrypted disk images. Use it as a starting point to develop a script that is suited to your use case and production environment.</div><div id="wwpID0E0ZB0HA" class="Body_Text">Following is an example of commands that use <span class="Code_Char">flash.sh</span>:</div><div id="wwpID0E0YB0HA" class="Code"># the disk encryption key in the EKB partition</div><div id="wwpID0E0XB0HA" class="Code">$ echo "00000000000000000000000000000000" &gt; ekb.key</div><div id="wwpID0E0WB0HA" class="Code">$ sudo ROOTFS_ENC=1 ./flash.sh -i "./ekb.key" &lt;board&gt; &lt;rootdev&gt;</div><div id="wwpID0E0VB0HA" class="Body_Text">The <span class="Code_Char">flash.sh</span> command line option <span class="Code_Char">‑‑i</span> specifies the key to be used for disk encryption. The reference implementation described above uses the EKB key. NVIDIA recommends that you customize the script to use a different key source for the sake of security. The key shown in the example above is all-zero to emphasize that you should not use it as given. When you change the key, change the EKS partition accordingly, and review the overall key and passphrase generation flow to be sure that everything works correctly.</div><div id="wwpID0E0UB0HA" class="Heading_5">How to Flash an Encrypted Rootfs to an External Storage Device</div><div id="wwpID0E0TB0HA" class="Body_Text" style="text-align: justify">To flash an encrypted rootfs generated by <span class="Code_Char">flash.sh</span> to an external storage device, use <span class="Code_Char">l4t_initrd_flash.sh</span> (also known as “the initrd flashing tool”). (See the section <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/flashing.html#wwpID0E0PI0HA" title="Flashing and Booting the Target Device">Flashing with initrd</a></span> in the topic <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/flashing.html#" title="Flashing and Booting the Target Device">Flashing and Booting the Target Device</a></span>).</div><div id="wwpID0E0SB0HA" class="Body_Text">Following is an example of commands that use <span class="Code_Char">l4t_initrd_flash.sh</span> to flash an encrypted rootfs to an NVMe SSD attached to a Jetson AGX Xavier series device:</div><div id="wwpID0E0RB0HA" class="Code">$ cd Linux_for_Tegra</div><div id="wwpID0E0QB0HA" class="Code">$ sudo ROOTFS_ENC=1 ./tools/kernel_flash/l4t_initrd_flash.sh --external-device nvme0n1p1 \</div><div id="wwpID0E0PB0HA" class="Code">&gt;   -c ./tools/kernel_flash/flash_l4t_nvme_rootfs_enc.xml --external-only -S 8GiB \</div><div id="wwpID0E0OB0HA" class="Code">&gt;    jetson-xavier external</div><div id="wwpID0E0NB0HA" class="Body_Text">Tools and instructions for flashing an encrypted rootfs with initrd may be found in the directory <span class="Code_Char">/Linux_for_Tegra/tools/kernel_flash/</span>. For more detailed information, see <span class="Code_Char">README_initrd_flash.txt</span> in that directory.</div><div id="wwpID0E0MB0HA" class="Heading_5">To Enhance initrd to Unlock an Encrypted Rootfs</div><div id="wwpID0E0LB0HA" class="Body_Text">To boot from an encrypted root filesystem, you need an initrd image which includes the necessary utilities (e.g. <span class="Code_Char">cryptsetup</span>) and scripts to set up the root device after the kernel is initialized, but before the rest of the operating system is booted. The image must contain the APP partition, which contains the <span class="Code_Char">/boot</span> branch of the rootfs (unencrypted), and the APP_ENC partition, which contains the rest of the rootfs (encrypted).</div><div id="wwpID0E0KB0HA" class="Body_Text">The boot flow diagram below shows that by default the bootloader (CBoot) uses the APP partition as the boot partition. U‑Boot checks the first partition after the primary GPT, which is the APP partition as well. Thus, the partition layout for an encrypted disk works for either bootloader.)</div><div id="wwpID0E0JB0HA" class="Body_Text">The init script in the initrd follows these steps to check the encrypted root device, unlock it, and mount it:</div><div id="wwpID0E0IB0HA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Verify that the <span class="Code_Char">root</span> parameter specifies the same device as the root device setting in <span class="Code_Char">/etc/crypttab</span>.</div><div id="wwpID0E0HB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Verify that the root device is a LUKS device.</div><div id="wwpID0E0GB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Unlock the encrypted root device with the per-device unique passphrase.</div><div id="wwpID0E0FB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Mount the root device.</div><div id="wwpID0E0EB0HA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Command the <span class="Code_Char">luks-srv</span> TA not to respond to further passphrase requests until reboot.</div><div id="wwpID0E0DB0HA" class="Heading_5">To modify initrd to unlock additional encrypted file systems</div><div id="wwpID0E0CB0HA" class="Body_Text">The file <span class="Code_Char">/etc/crypttab</span>, kept in initrd, describes encrypted block devices that are set up during system boot. Each line of this file has the form:</div><div id="wwpID0E0BB0HA" class="Code">&lt;volume-name&gt; UUID=&lt;uuid&gt;</div><div id="wwpID0E0AB0HA" class="Body_Text">Where:</div><div id="wwpID0E6HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">&lt;volume-name&gt;</span> is the name of a volume in which decrypted data is to be placed. Its block device is set up in <span class="Code_Char">/dev/mapper/</span>. <span class="Code_Char">&lt;volume-name&gt;</span> must be unique across all lines in the file.</div><div id="wwpID0E5HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•	</span></span><span class="Code_Char">&lt;uuid&gt;</span> is the UUID of the underlying block device containing encrypted data.</div><div id="wwpID0E4HA" class="Body_Text">Here are two examples of entries in <span class="Code_Char">/etc/crypttab</span>:</div><div id="wwpID0E3HA" class="Code">crypt_root UUID=b5600ed6-69e7-42b8-bee3-ecfdd12649d1</div><div id="wwpID0E2HA" class="Code">crypt_UDA UUID=cf6fa01d-1127-4612-9992-2f6db77385e0</div><div id="wwpID0E1HA" class="Body_Text">If your device has several encrypted file systems, you must add a line to <span class="Code_Char">/etc/crypttab</span> for each one you want Bootloader to unlock.</div><div id="wwpID0EZHA" class="Body_Text">This is an example of how to unlock an encrypted file system:</div><div id="wwpID0EYHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span>Enter this command to find the UUID of the encrypted file system:</div><div id="wwpID0EXHA" class="Code">$ sudo blkid | grep TYPE=\"crypto_LUKS\"</div><div id="wwpID0EWHA" class="List_Continue">This command line displays a line of output for each encrypted disk that includes the disk’s UUID. Such a line looks like this:</div><div id="wwpID0EVHA" class="Code">/dev/mmcblk0p43: UUID="5096aa4d-6590-429b-9295-a1fe041b8fa3" TYPE="crypto_LUKS" PARTLABEL="UDA" PARTUUID="2b23da7f-2f18-44bf-9e1d-6e3a3a39ad21"</div><div id="wwpID0EUHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span>Unpack the initrd. For instructions, see the section <span class="Hyperlink"><a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/flashing.html#wwpID0EQHA" title="Flashing and Booting the Target Device">Modifying Jetson RAM Disk</a></span>.</div><div id="wwpID0ETHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span>Add a line to <span class="Code_Char">/etc/crypttab</span> for each encrypted file system that you want to unlock at subsequent reboots. The line specifies the UUID of the file system to be unlocked, as in this example:</div><div id="wwpID0ESHA" class="Code">crypt_fs UUID="5096aa4d-6590-429b-9295-a1fe041b8fa3"</div><div id="wwpID0ERHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Repackage the initrd and store it in <span class="Code_Char">/boot</span>, replacing the initrd that was originally there.</div><div id="wwpID0EQHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>5.	</span></span>Create a subdirectory in <span class="Code_Char">/mnt</span> in which initrd can mount each unlocked file system during the initialization process. For the sake of simplicity, NVIDIA recommends giving each subdirectory the same name as the volume to be mounted there. For the volume specified in step&nbsp;<a href="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/bootloader_disk_encryption.html#wwpID0ETHA" title="Disk Encryption">3</a>, the subdirectory would be named <span class="Code_Char">crypt_fs</span>:</div><div id="wwpID0EPHA" class="Code">$ mkdir -p /mnt/crypt_fs</div><div id="wwpID0EOHA" class="Body_Text">Bootloader unlocks your encrypted file system at each subsequent reboot.</div><div id="wwpID0ENHA" class="Heading_5">Summary</div><div id="wwpID0EMHA" class="Body_Text">The following diagram shows the overall flow of the encrypted disk unlocking process.</div><div class="ww_skin_page_overflow"><div id="wwpID0ELHA" class="Body_Text"><img class="Default" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/image4_8.png" style="display: inline; left: 0pt; top: 0pt" alt="Diagram Description automatically generated" title="Diagram Description automatically generated" /></div></div><div id="wwpID0EKHA" class="Body_Text">The steps of the process are:</div><div id="wwpID0EJHA" class="List_Number" style="text-indent: -18pt"><span class="WebWorks_Number" style="width: 18pt"><span>1.	</span></span><span class="Code_Char">nvluks-srv-app</span> queries the hardware-based passphrase from the Trusty <span class="Code_Char">luks-srv</span> TA and pass it to the <span class="Code_Char">cryptsetup</span> utility.</div><div id="wwpID0EIHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>2.	</span></span><span class="Code_Char">cryptsetup</span> unlocks the disk and decrypts the disk encryption key (DEK) with the passphrase.</div><div id="wwpID0EHHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>3.	</span></span><span class="Code_Char">cryptsetup</span> invokes the <span class="Code_Char">DMCrypt</span> kernel module and loads the key into the kernel. <span class="Code_Char">DMCrypt</span> uses the <span class="Code_Char">tegra-crypto</span> driver, which uses Security Engine (SE) hardware for data encryption and decryption.</div><div id="wwpID0EGHA" class="List_Number"><span class="WebWorks_Number" style="width: 18pt"><span>4.	</span></span>Subsequent disk I/O is routed through <span class="Code_Char">DMCrypt</span>, which decrypts and encrypts data as it reads and writes.</div><H3 id="wwpID0EFHA" class="Heading_3">Manufacturing process</H3><div id="wwpID0EEHA" class="Body_Text">The following diagram illustrates the post-development manufacturing process for a Jetson-based device:</div><div class="ww_skin_page_overflow"><div id="wwpID0EDHA" class="Body_Text"><img class="Default" src="../Tegra%20Linux%20Driver%20Package%20Development%20Guide/images/image5_7.png" style="display: inline; left: 0pt; top: 0pt" alt="Diagram Description automatically generated" title="Diagram Description automatically generated" /></div></div><div id="wwpID0ECHA" class="Body_Text">All disk images and blobs to be flashed onto production devices must be generated on a secure system. The HSM holds all of the security keys needed in the manufacturing process. If more than one production device is to be flashed at a time, the security machine must be able to deploy images to other systems (flashing machines) for flashing devices.</div><div id="wwpID0EBHA" class="Body_Text">If the device is designed to use per-device encrypted disk images, the images must be generated one at a time on the security machine.</div></div><div id="page_dates"></div><!-- Related Topics --><!--                --><footer><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br /></footer></div></div><input type="hidden" id="preserve_unknown_file_links" value="false"></input><noscript><div id="noscript_warning">This site works best with JavaScript enabled</div></noscript><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></body></html>